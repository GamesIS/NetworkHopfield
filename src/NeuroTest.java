//import java.util.Random;
//
//public class NeuroTest {
//    // члены класса
//
//
//    //количество слоёв в сети
//    public int layersQ;
//    //количество слоёв в сети (свойство)
//
//    //количество нейронов в каждом слое
//    //[номер слоя]
//    public int [] neuronsQ;
//
//    //матрица весов синаптических связей
//    //[номер слоя][номер нейрона][номер синапса]
//    public double [][][] w;
//
//    //текущее состояние каждого нейрона
//    //[номер слоя][номер нейрона]
//    public double [][] state;
//
//
//    //Переменные - для обучения
//    public int epoches;
//    public double [][] input;
//    public double[][] output;
//    public double [][] inputTest;
//    public double[][] outputTest;
//
//    double shift;	// значение нейронов-смещений
//    double[] errorArray	 // массив ошибки
//
//    private void сreate(int[] NQ)
//    {
//
//        //количество нейронов в слоях
//        neuronsQ = new int[NQ.length];
//        for (int i=0;i<NQ.length;i++)
//        {
//            neuronsQ[i]=NQ[i];
//        }
////......................................................................
//        //количество слоёв сети
//        layersQ=NQ.length;
////......................................................................
//        //создаём матрицу весовых коэффициентов
//        w = new double [layersQ][][];
//        Random r = new Random();
//        for (int i=1;i<(layersQ);i++)		//цикл по слоям (кроме первого)
//        {
//            w[i]= new double [(neuronsQ[i]+1)][(neuronsQ[i-1]+1)];
//            for (int j=0;j<(neuronsQ[i]+1);j++)		//цикл по нейронам в каждом слое
//            {
//
//                for (int k=0;k<(neuronsQ[i-1]+1);k++)		//цикл по синапсам каждого нейрона
//                {
//                    w[i][j][k]=r.nextDouble()-0.5;		//инициализируем веса случайными значениями (-0.5 ... 0.5)
//                }
//            }
//        }
////......................................................................
//
//        //инициализируем параметры сети значениями по умолчанию
//        this.InitDefaultParams();
//    }
//
//
//    public double activate (double x)// Функция активации (Нормальзации значения [0;1])
//    {
//        return (1/(1+Math.pow(Math.E, -x)));
//    }
//
//    //функция подачи массива double на вход
//    public void InitInput (double[] input)
//    {
//
//        //копируем поданный масив на входной слой сети
//        for (int i=1;i<(input.length+1);i++)
//        {
//            state[0][i]=activate(input[i-1]);
//        }
////......................................................................
//    }
//    //функция возвращения массива с выхода
//    public double [] GetOutput ()
//    {
//        double[] output = new double[neuronsQ[layersQ-1]];
//        for (int i=0;i<output.length;i++)
//        {
//            output[i]=state[layersQ-1][i];
//        }
//        return output;
//
//
//    }
//    //=====================================================================
//    //функция работы сети (прямое распространение сигналов)
//    public void Operate()
//    {
//
//
//        double st;
//        for (int i=1;i<(layersQ);i++)	//цикл по слоям (со второго)
//        {
//            for (int j=FirstTmp;j<LastTmp;j++) //цикл по нейронам каждого слоя (кроме первого (нейрона-смещения) для не последних слоёв)
//            {
//                st=0;
//                for (int k=0;k<(neuronsQ[i-1]+1);k++) //цикл по синапсам
//                {
//                    st+=(state[i-1][k]*w[i][j,k]);	//считаем взвешенную сумму
//                }
//
//                //пропускаем взвешенную сумму через активационную функцию (сигмоид)
//                state[i][j]=activate(st);
//            }
//            //state[i][0]=Shift;  //нейрон-смещение остаётся единицей
//        }
//
//    }//~Operate
//
//    //Принимает "рваный" массив массивов входных образов [номер образа][номер признака]
//// "рваный" массив массивов выходных образов [номер образа][номер признака]
//// и количество эпох
//
//    public void Study( double [][] input, double[][] output, int epoches)
//    {
//
//        //создаём массив ошибок по эпохам
//        ErrorArray= new double[epoches];
//        //создаём массив ошибок по тестовому множеству по эпохам
//        ErrorArrayTest= new double[epoches];
//        int [] hits =new int[epoches];
//
//        double[][] delt; //дельта
//
//        //размерность delt совпадает с размерностью матрицы состояний
//        delt=new double[layersQ][];
//        for (int y=0;y<layersQ;y++)
//            delt[y]=new double[neuronsQ[y]+1];
//
//
//
//
//        //.........................................................................................................
//        Random rnd=new Random();
//        for (int i=1;i<(layersQ);i++)		//цикл по слоям (кроме первого)
//        {
//            int first,last;
//            if(i==layersQ-1) //если слой последний
//            {
//                first=0;
//                last=neuronsQ[i];
//            }
//            else
//            {
//                first=1;
//                last=neuronsQ[i]+1;
//            }
//            for (int j=0;j<(last);j++)		//цикл по нейронам в каждом слое
//            {
//                for (int k=0;k<(neuronsQ[i-1]+1);k++)		//цикл по синапсам каждого нейрона
//                {
//                    w[i][j,k]=rnd.NextDouble()/2-0.25; //инициализируем веса малыми случайными значениями (-0.1 ... 0.1)
//                }
//            }
//        }
//
////.........................................................................................................
//
//        for (int ep=0;ep<epoches;ep++) //начало эпохи обучения
//        {
//
//            CurEpochs=ep;
//
//
////.........................................................................................................
//
//            int[] rn=new int[input.GetLength(0)];
//            for (int e=0;e<r Length;e++)
//            {
//                rn[e]=e;
//            }
//
////.........................................................................................................
//
//            int i;
//            for (int img=0;img<input.GetLength(0);img++) //цикл по всем образам
//            {
//                i = rn[img];
//                InitInput(input[i]); //подаём на вход очередной образ
//                Operate(); // осущ. прогон сети
//                double[] arr= new double[output[i].Length];
//                arr=GetOutput();//записываем выход в массив arr
////.........................................................................................................
//
//
//
//
//                if (flag)//если ошибка велика  и надо корректировать веса
//                {
////.........................................................................................................
//                    //сначала подстраиваем веса нейронов последнего слоя
//
//                    for(int r=0;r<(neuronsQ[ layersQ-1]);r++) //цикл по нейронам
//                    {
//                        //находим "дельту" (хар-ка уровня нейрона)
//                        //(дельта)=(производная логистич. ф-ции)*(абс.ошибка)
//                        delt[ layersQ-1][r]=( state[ layersQ-1][r] * (1- state[ layersQ-1][r])) * ( activate(output[i][r])-arr[r]);
//
//                        for (int w=0;w<( neuronsQ[ layersQ-2]+1);w++) //цикл по весам
//                        {
//
//                            //(Вес)=(Вес)+(Выход передающего нейрона)*(Дельта)*(Скорость)
//                            w[ layersQ-1][r][w]+=( state[ layersQ-2][w]*delt[ layersQ-1][r]); //+  Inertion*corr[ layersQ-1][r,w]);
//
//                        }//~цикл по весам w
//
//                    }//~цикл по нейронам r
////.........................................................................................................
//
//                    //подстраиваем веса нейронов остальных слоёв
//                    for (int t= layersQ-2;t>0;t--)//цикл по слоям от предпоследнего ко второму
//                    {
//                        for(int r=1;r<( neuronsQ[t]+1);r++) //цикл по нейронам
//                        {
//                            //находим сумму  "дельт" следующего слоя, умноженных на веса
//                            double sum=0;
//
//                            for (int s=1;s<( neuronsQ[t+1]+1);s++)//цикл по нейронам следующего слоя
//                            {
//                                sum += (delt[t+1][s]* w[t+1][s,r]);
//                            }
//
//                            //теперь найдём дельту для этого нейрона
//                            delt[t][r]=sum*( state[t][r]*(1- state[t][r]));
//
//                            //корректируем питающие синапсы
//                            for(int a=0;a<( neuronsQ[t-1]+1);a++)//цикл по весам
//                            {
//                                //корректируем веса
//                                //(Вес)=(Вес)+(Выход передающего нейрона)*(Дельта)*(Скорость)
//                                w[t][r][a]+=( state[t-1][a]*delt[t][r]);// +  Inertion*corr[t][r,a]);
//
//                            }//~цикл по весам a
//
//                        } //~цикл по нейронам r
//
//                    }//~цикл по слоям от предпоследнего ко второму t
//
//                }//~корректировка весов
//                ErrorArray[ep]+= GetError(output[i]);
//            }//~цикл по всем образам i
//
//
//
//        }//~конец эпохи обучения
//
//
//    }//~Study функция
//}
